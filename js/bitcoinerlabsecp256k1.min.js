(function(t){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=t()}else if(typeof define==="function"&&define.amd){define([],t)}else{var e;if(typeof window!=="undefined"){e=window}else if(typeof global!=="undefined"){e=global}else if(typeof self!=="undefined"){e=self}else{e=this}e.bitcoinerlabsecp256k1=t()}})(function(){var t,e,n;return function(){function f(s,i,c){function a(n,t){if(!i[n]){if(!s[n]){var e="function"==typeof require&&require;if(!t&&e)return e(n,!0);if(u)return u(n,!0);var r=new Error("Cannot find module '"+n+"'");throw r.code="MODULE_NOT_FOUND",r}var o=i[n]={exports:{}};s[n][0].call(o.exports,function(t){var e=s[n][1][t];return a(e||t)},o,o.exports,f,s,i,c)}return i[n].exports}for(var u="function"==typeof require&&require,t=0;t<c.length;t++)a(c[t]);return a}return f}()({1:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:true});n.getHash=i;n.createCurve=c;const r=t("@noble/hashes/hmac");const o=t("@noble/hashes/utils");const s=t("./abstract/weierstrass.js");function i(n){return{hash:n,hmac:(t,...e)=>(0,r.hmac)(n,t,(0,o.concatBytes)(...e)),randomBytes:o.randomBytes}}function c(e,t){const n=t=>(0,s.weierstrass)({...e,...i(t)});return{...n(t),create:n}}},{"./abstract/weierstrass.js":6,"@noble/hashes/hmac":11,"@noble/hashes/utils":13}],2:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:true});n.wNAF=a;n.pippenger=u;n.precomputeMSMUnsafe=f;n.validateBasic=p;const r=t("./modular.js");const d=t("./utils.js");const l=BigInt(0);const b=BigInt(1);function m(t,e){const n=e.negate();return t?n:e}function s(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function E(t,e){s(t,e);const n=Math.ceil(e/t)+1;const r=2**(t-1);return{windows:n,windowSize:r}}function h(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((t,e)=>{if(!(t instanceof n))throw new Error("invalid point at index "+e)})}function w(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((t,e)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+e)})}const o=new WeakMap;const i=new WeakMap;function c(t){return i.get(t)||1}function a(y,g){return{constTimeNegate:m,hasPrecomputes(t){return c(t)!==1},unsafeLadder(t,e,n=y.ZERO){let r=t;while(e>l){if(e&b)n=n.add(r);r=r.double();e>>=b}return n},precomputeWindow(t,e){const{windows:n,windowSize:r}=E(e,g);const o=[];let s=t;let i=s;for(let t=0;t<n;t++){i=s;o.push(i);for(let t=1;t<r;t++){i=i.add(s);o.push(i)}s=i.double()}return o},wNAF(t,n,r){const{windows:o,windowSize:s}=E(t,g);let i=y.ZERO;let c=y.BASE;const a=BigInt(2**t-1);const u=2**t;const f=BigInt(t);for(let e=0;e<o;e++){const l=e*s;let t=Number(r&a);r>>=f;if(t>s){t-=u;r+=b}const d=l;const h=l+Math.abs(t)-1;const w=e%2!==0;const p=t<0;if(t===0){c=c.add(m(w,n[d]))}else{i=i.add(m(p,n[h]))}}return{p:i,f:c}},wNAFUnsafe(t,r,o,s=y.ZERO){const{windows:e,windowSize:i}=E(t,g);const c=BigInt(2**t-1);const a=2**t;const u=BigInt(t);for(let n=0;n<e;n++){const f=n*i;if(o===l)break;let t=Number(o&c);o>>=u;if(t>i){t-=a;o+=b}if(t===0)continue;let e=r[f+Math.abs(t)-1];if(t<0)e=e.negate();s=s.add(e)}return s},getPrecomputes(t,e,n){let r=o.get(e);if(!r){r=this.precomputeWindow(e,t);if(t!==1)o.set(e,n(r))}return r},wNAFCached(t,e,n){const r=c(t);return this.wNAF(r,this.getPrecomputes(r,t,n),e)},wNAFCachedUnsafe(t,e,n,r){const o=c(t);if(o===1)return this.unsafeLadder(t,e,r);return this.wNAFUnsafe(o,this.getPrecomputes(o,t,n),e,r)},setWindowSize(t,e){s(e,g);i.set(t,e);o.delete(t)}}}function u(t,e,r,o){h(r,t);w(o,e);if(r.length!==o.length)throw new Error("arrays of points and scalars must have equal length");const s=t.ZERO;const i=(0,d.bitLen)(BigInt(r.length));const c=i>12?i-3:i>4?i-2:i?2:1;const a=(1<<c)-1;const u=new Array(a+1).fill(s);const n=Math.floor((e.BITS-1)/c)*c;let f=s;for(let e=n;e>=0;e-=c){u.fill(s);for(let t=0;t<o.length;t++){const l=o[t];const i=Number(l>>BigInt(e)&BigInt(a));u[i]=u[i].add(r[t])}let n=s;for(let t=u.length-1,e=s;t>0;t--){e=e.add(u[t]);n=n.add(e)}f=f.add(n);if(e!==0)for(let t=0;t<c;t++)f=f.double()}return f}function f(t,i,c,a){s(a,i.BITS);h(c,t);const u=t.ZERO;const o=2**a-1;const f=Math.ceil(i.BITS/a);const l=BigInt((1<<a)-1);const d=c.map(n=>{const r=[];for(let t=0,e=n;t<o;t++){r.push(e);e=e.add(n)}return r});return e=>{w(e,i);if(e.length>c.length)throw new Error("array of scalars must be smaller than array of points");let n=u;for(let t=0;t<f;t++){if(n!==u)for(let t=0;t<a;t++)n=n.double();const r=BigInt(f*a-(t+1)*a);for(let t=0;t<e.length;t++){const o=e[t];const s=Number(o>>r&l);if(!s)continue;n=n.add(d[t][s-1])}}return n}}function p(t){(0,r.validateField)(t.Fp);(0,d.validateObject)(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"});return Object.freeze({...(0,r.nLength)(t.n,t.nBitLength),...t,...{p:t.Fp.ORDER}})}},{"./modular.js":4,"./utils.js":5}],3:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:true});n.expand_message_xmd=v;n.expand_message_xof=x;n.hash_to_field=u;n.isogenyMap=r;n.createHasher=o;const b=t("./modular.js");const m=t("./utils.js");const E=m.bytesToNumberBE;function w(e,n){B(e);B(n);if(e<0||e>=1<<8*n)throw new Error("invalid I2OSP input: "+e);const r=Array.from({length:n}).fill(0);for(let t=n-1;t>=0;t--){r[t]=e&255;e>>>=8}return new Uint8Array(r)}function p(e,n){const r=new Uint8Array(e.length);for(let t=0;t<e.length;t++){r[t]=e[t]^n[t]}return r}function B(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function v(t,e,n,r){(0,m.abytes)(t);(0,m.abytes)(e);B(n);if(e.length>255)e=r((0,m.concatBytes)((0,m.utf8ToBytes)("H2C-OVERSIZE-DST-"),e));const{outputLen:o,blockLen:s}=r;const i=Math.ceil(n/o);if(n>65535||i>255)throw new Error("expand_message_xmd: invalid lenInBytes");const c=(0,m.concatBytes)(e,w(e.length,1));const a=w(0,s);const u=w(n,2);const f=new Array(i);const l=r((0,m.concatBytes)(a,t,u,w(0,1),c));f[0]=r((0,m.concatBytes)(l,w(1,1),c));for(let t=1;t<=i;t++){const h=[p(l,f[t-1]),w(t+1,1),c];f[t]=r((0,m.concatBytes)(...h))}const d=(0,m.concatBytes)(...f);return d.slice(0,n)}function x(t,e,n,r,o){(0,m.abytes)(t);(0,m.abytes)(e);B(n);if(e.length>255){const s=Math.ceil(2*r/8);e=o.create({dkLen:s}).update((0,m.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:n}).update(t).update(w(n,2)).update(e).update(w(e.length,1)).digest()}function u(t,n,e){(0,m.validateObject)(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:s,hash:i,expand:c,DST:a}=e;(0,m.abytes)(t);B(n);const u=typeof a==="string"?(0,m.utf8ToBytes)(a):a;const f=r.toString(2).length;const l=Math.ceil((f+o)/8);const d=n*s*l;let h;if(c==="xmd"){h=v(t,u,d,i)}else if(c==="xof"){h=x(t,u,d,o,i)}else if(c==="_internal_pass"){h=t}else{throw new Error('expand must be "xmd" or "xof"')}const w=new Array(n);for(let e=0;e<n;e++){const p=new Array(s);for(let t=0;t<s;t++){const y=l*(t+e*s);const g=h.subarray(y,y+l);p[t]=(0,b.mod)(E(g),r)}w[e]=p}return w}function r(i,t){const c=t.map(t=>Array.from(t).reverse());return(n,t)=>{const[e,r,o,s]=c.map(t=>t.reduce((t,e)=>i.add(i.mul(t,n),e)));n=i.div(e,r);t=i.mul(t,i.div(o,s));return{x:n,y:t}}}function o(i,c,a){if(typeof c!=="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(t,e){const n=u(t,2,{...a,DST:a.DST,...e});const r=i.fromAffine(c(n[0]));const o=i.fromAffine(c(n[1]));const s=r.add(o).clearCofactor();s.assertValidity();return s},encodeToCurve(t,e){const n=u(t,1,{...a,DST:a.encodeDST,...e});const r=i.fromAffine(c(n[0])).clearCofactor();r.assertValidity();return r},mapToCurve(t){if(!Array.isArray(t))throw new Error("mapToCurve: expected array of bigints");for(const n of t)if(typeof n!=="bigint")throw new Error("mapToCurve: expected array of bigints");const e=i.fromAffine(c(t)).clearCofactor();e.assertValidity();return e}}}},{"./modular.js":4,"./utils.js":5}],4:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:true});n.isNegativeLE=void 0;n.mod=y;n.pow=g;n.pow2=o;n.invert=l;n.tonelliShanks=d;n.FpSqrt=b;n.validateField=B;n.FpPow=v;n.FpInvertBatch=x;n.FpDiv=A;n.FpLegendre=S;n.FpIsSquare=O;n.nLength=T;n.Field=I;n.FpSqrtOdd=R;n.FpSqrtEven=j;n.hashToPrivateScalar=L;n.getFieldBytesLength=k;n.getMinHashLength=U;n.mapHashToField=_;const a=t("./utils.js");const h=BigInt(0),w=BigInt(1),p=BigInt(2),r=BigInt(3);const s=BigInt(4),i=BigInt(5),c=BigInt(8);const u=BigInt(9),f=BigInt(16);function y(t,e){const n=t%e;return n>=h?n:e+n}function g(t,e,n){if(e<h)throw new Error("invalid exponent, negatives unsupported");if(n<=h)throw new Error("invalid modulus");if(n===w)return h;let r=w;while(e>h){if(e&w)r=r*t%n;t=t*t%n;e>>=w}return r}function o(t,e,n){let r=t;while(e-- >h){r*=r;r%=n}return r}function l(t,e){if(t===h)throw new Error("invert: expected non-zero number");if(e<=h)throw new Error("invert: expected positive modulus, got "+e);let n=y(t,e);let r=e;let o=h,s=w,i=w,c=h;while(n!==h){const u=r/n;const f=r%n;const l=o-i*u;const d=s-c*u;r=n,n=f,o=i,s=c,i=l,c=d}const a=r;if(a!==w)throw new Error("invert: does not exist");return y(o,e)}function d(t){const a=(t-w)/p;let u,f,l;for(u=t-w,f=0;u%p===h;u/=p,f++);for(l=p;l<t&&g(l,a,t)!==t-w;l++){if(l>1e3)throw new Error("Cannot find square root: likely non-prime P")}if(f===1){const o=(t+w)/s;return function t(e,n){const r=e.pow(n,o);if(!e.eql(e.sqr(r),n))throw new Error("Cannot find square root");return r}}const d=(u+w)/p;return function t(n,e){if(n.pow(e,a)===n.neg(n.ONE))throw new Error("Cannot find square root");let r=f;let o=n.pow(n.mul(n.ONE,l),u);let s=n.pow(e,d);let i=n.pow(e,u);while(!n.eql(i,n.ONE)){if(n.eql(i,n.ZERO))return n.ZERO;let e=1;for(let t=n.sqr(i);e<r;e++){if(n.eql(t,n.ONE))break;t=n.sqr(t)}const c=n.pow(o,w<<BigInt(r-e-1));o=n.sqr(c);s=n.mul(s,c);i=n.mul(i,o);r=e}return s}}function b(t){if(t%s===r){const o=(t+w)/s;return function t(e,n){const r=e.pow(n,o);if(!e.eql(e.sqr(r),n))throw new Error("Cannot find square root");return r}}if(t%c===i){const a=(t-i)/c;return function t(e,n){const r=e.mul(n,p);const o=e.pow(r,a);const s=e.mul(n,o);const i=e.mul(e.mul(s,p),o);const c=e.mul(s,e.sub(i,e.ONE));if(!e.eql(e.sqr(c),n))throw new Error("Cannot find square root");return c}}if(t%f===u){}return d(t)}const m=(t,e)=>(y(t,e)&w)===w;n.isNegativeLE=m;const E=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function B(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"};const n=E.reduce((t,e)=>{t[e]="function";return t},e);return(0,a.validateObject)(t,n)}function v(t,e,n){if(n<h)throw new Error("invalid exponent, negatives unsupported");if(n===h)return t.ONE;if(n===w)return e;let r=t.ONE;let o=e;while(n>h){if(n&w)r=t.mul(r,o);o=t.sqr(o);n>>=w}return r}function x(r,t){const o=new Array(t.length);const e=t.reduce((t,e,n)=>{if(r.is0(e))return t;o[n]=t;return r.mul(t,e)},r.ONE);const n=r.inv(e);t.reduceRight((t,e,n)=>{if(r.is0(e))return t;o[n]=r.mul(t,o[n]);return r.mul(t,e)},n);return o}function A(t,e,n){return t.mul(e,typeof n==="bigint"?l(n,t.ORDER):t.inv(n))}function S(t){const n=(t-w)/p;return(t,e)=>t.pow(e,n)}function O(n){const r=S(n.ORDER);return t=>{const e=r(n,t);return n.eql(e,n.ZERO)||n.eql(e,n.ONE)}}function T(t,e){const n=e!==undefined?e:t.toString(2).length;const r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function I(n,t,e=false,r={}){if(n<=h)throw new Error("invalid field: expected ORDER > 0, got "+n);const{nBitLength:o,nByteLength:s}=T(n,t);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i;const c=Object.freeze({ORDER:n,isLE:e,BITS:o,BYTES:s,MASK:(0,a.bitMask)(o),ZERO:h,ONE:w,create:t=>y(t,n),isValid:t=>{if(typeof t!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return h<=t&&t<n},is0:t=>t===h,isOdd:t=>(t&w)===w,neg:t=>y(-t,n),eql:(t,e)=>t===e,sqr:t=>y(t*t,n),add:(t,e)=>y(t+e,n),sub:(t,e)=>y(t-e,n),mul:(t,e)=>y(t*e,n),pow:(t,e)=>v(c,t,e),div:(t,e)=>y(t*l(e,n),n),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:t=>l(t,n),sqrt:r.sqrt||(t=>{if(!i)i=b(n);return i(c,t)}),invertBatch:t=>x(c,t),cmov:(t,e,n)=>n?e:t,toBytes:t=>e?(0,a.numberToBytesLE)(t,s):(0,a.numberToBytesBE)(t,s),fromBytes:t=>{if(t.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+t.length);return e?(0,a.bytesToNumberLE)(t):(0,a.bytesToNumberBE)(t)}});return Object.freeze(c)}function R(t,e){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const n=t.sqrt(e);return t.isOdd(n)?n:t.neg(n)}function j(t,e){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const n=t.sqrt(e);return t.isOdd(n)?t.neg(n):n}function L(t,e,n=false){t=(0,a.ensureBytes)("privateHash",t);const r=t.length;const o=T(e).nByteLength+8;if(o<24||r<o||r>1024)throw new Error("hashToPrivateScalar: expected "+o+"-1024 bytes of input, got "+r);const s=n?(0,a.bytesToNumberLE)(t):(0,a.bytesToNumberBE)(t);return y(s,e-w)+w}function k(t){if(typeof t!=="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function U(t){const e=k(t);return e+Math.ceil(e/2)}function _(t,e,n=false){const r=t.length;const o=k(e);const s=U(e);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const i=n?(0,a.bytesToNumberLE)(t):(0,a.bytesToNumberBE)(t);const c=y(i,e-w)+w;return n?(0,a.numberToBytesLE)(c,o):(0,a.numberToBytesBE)(c,o)}},{"./utils.js":5}],5:[function(H,P,t){"use strict";Object.defineProperty(t,"__esModule",{value:true});t.notImplemented=t.bitMask=void 0;t.isBytes=s;t.abytes=i;t.abool=n;t.bytesToHex=a;t.numberToHexUnpadded=u;t.hexToNumber=f;t.hexToBytes=h;t.bytesToNumberBE=w;t.bytesToNumberLE=p;t.numberToBytesBE=y;t.numberToBytesLE=g;t.numberToVarBytesBE=b;t.ensureBytes=m;t.concatBytes=E;t.equalBytes=B;t.utf8ToBytes=v;t.inRange=A;t.aInRange=S;t.bitLen=O;t.bitGet=T;t.bitSet=I;t.createHmacDrbg=k;t.validateObject=_;t.memoized=q;const r=BigInt(0);const o=BigInt(1);const e=BigInt(2);function s(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function i(t){if(!s(t))throw new Error("Uint8Array expected")}function n(t,e){if(typeof e!=="boolean")throw new Error(t+" boolean expected, got "+e)}const c=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function a(e){i(e);let n="";for(let t=0;t<e.length;t++){n+=c[e[t]]}return n}function u(t){const e=t.toString(16);return e.length&1?"0"+e:e}function f(t){if(typeof t!=="string")throw new Error("hex string expected, got "+typeof t);return t===""?r:BigInt("0x"+t)}const l={_0:48,_9:57,A:65,F:70,a:97,f:102};function d(t){if(t>=l._0&&t<=l._9)return t-l._0;if(t>=l.A&&t<=l.F)return t-(l.A-10);if(t>=l.a&&t<=l.f)return t-(l.a-10);return}function h(n){if(typeof n!=="string")throw new Error("hex string expected, got "+typeof n);const t=n.length;const r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const o=new Uint8Array(r);for(let t=0,e=0;t<r;t++,e+=2){const s=d(n.charCodeAt(e));const i=d(n.charCodeAt(e+1));if(s===undefined||i===undefined){const c=n[e]+n[e+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+e)}o[t]=s*16+i}return o}function w(t){return f(a(t))}function p(t){i(t);return f(a(Uint8Array.from(t).reverse()))}function y(t,e){return h(t.toString(16).padStart(e*2,"0"))}function g(t,e){return y(t,e).reverse()}function b(t){return h(u(t))}function m(e,t,n){let r;if(typeof t==="string"){try{r=h(t)}catch(t){throw new Error(e+" must be hex string or Uint8Array, cause: "+t)}}else if(s(t)){r=Uint8Array.from(t)}else{throw new Error(e+" must be hex string or Uint8Array")}const o=r.length;if(typeof n==="number"&&o!==n)throw new Error(e+" of length "+n+" expected, got "+o);return r}function E(...n){let e=0;for(let t=0;t<n.length;t++){const o=n[t];i(o);e+=o.length}const r=new Uint8Array(e);for(let t=0,e=0;t<n.length;t++){const o=n[t];r.set(o,e);e+=o.length}return r}function B(e,n){if(e.length!==n.length)return false;let r=0;for(let t=0;t<e.length;t++)r|=e[t]^n[t];return r===0}function v(t){if(typeof t!=="string")throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}const x=t=>typeof t==="bigint"&&r<=t;function A(t,e,n){return x(t)&&x(e)&&x(n)&&e<=t&&t<n}function S(t,e,n,r){if(!A(e,n,r))throw new Error("expected valid "+t+": "+n+" <= n < "+r+", got "+e)}function O(t){let e;for(e=0;t>r;t>>=o,e+=1);return e}function T(t,e){return t>>BigInt(e)&o}function I(t,e,n){return t|(n?o:r)<<BigInt(e)}const R=t=>(e<<BigInt(t-1))-o;t.bitMask=R;const j=t=>new Uint8Array(t);const L=t=>Uint8Array.from(t);function k(t,r,e){if(typeof t!=="number"||t<2)throw new Error("hashLen must be a number");if(typeof r!=="number"||r<2)throw new Error("qByteLen must be a number");if(typeof e!=="function")throw new Error("hmacFn must be a function");let o=j(t);let n=j(t);let s=0;const i=()=>{o.fill(1);n.fill(0);s=0};const c=(...t)=>e(n,o,...t);const a=(t=j())=>{n=c(L([0]),t);o=c();if(t.length===0)return;n=c(L([1]),t);o=c()};const u=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const e=[];while(t<r){o=c();const n=o.slice();e.push(n);t+=o.length}return E(...e)};const f=(t,e)=>{i();a(t);let n=undefined;while(!(n=e(u())))a();i();return n};return f}const U={bigint:t=>typeof t==="bigint",function:t=>typeof t==="function",boolean:t=>typeof t==="boolean",string:t=>typeof t==="string",stringOrUint8Array:t=>typeof t==="string"||s(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t==="function"&&Number.isSafeInteger(t.outputLen)};function _(s,t,e={}){const n=(t,e,n)=>{const r=U[e];if(typeof r!=="function")throw new Error("invalid validator function");const o=s[t];if(n&&o===undefined)return;if(!r(o,s)){throw new Error("param "+String(t)+" is invalid. Expected "+e+", got "+o)}};for(const[r,o]of Object.entries(t))n(r,o,false);for(const[r,o]of Object.entries(e))n(r,o,true);return s}const N=()=>{throw new Error("not implemented")};t.notImplemented=N;function q(o){const s=new WeakMap;return(t,...e)=>{const n=s.get(t);if(n!==undefined)return n;const r=o(t,...e);s.set(t,r);return r}}},{}],6:[function(t,e,L){"use strict";Object.defineProperty(L,"__esModule",{value:true});L.DER=L.DERErr=void 0;L.weierstrassPoints=P;L.weierstrass=o;L.SWUFpSqrtRatio=s;L.mapToCurveSimpleSWU=c;const f=t("./curve.js");const l=t("./modular.js");const k=t("./utils.js");const U=t("./utils.js");function _(t){if(t.lowS!==undefined)(0,U.abool)("lowS",t.lowS);if(t.prehash!==undefined)(0,U.abool)("prehash",t.prehash)}function h(t){const e=(0,f.validateBasic)(t);k.validateObject(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO)){throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0")}if(typeof n!=="object"||typeof n.beta!=="bigint"||typeof n.splitScalar!=="function"){throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}}return Object.freeze({...e})}const{bytesToNumberBE:n,hexToBytes:d}=k;class r extends Error{constructor(t=""){super(t)}}L.DERErr=r;L.DER={Err:r,_tlv:{encode:(t,e)=>{const{Err:n}=L.DER;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length&1)throw new n("tlv.encode: unpadded data");const r=e.length/2;const o=k.numberToHexUnpadded(r);if(o.length/2&128)throw new n("tlv.encode: long form length too big");const s=r>127?k.numberToHexUnpadded(o.length/2|128):"";const i=k.numberToHexUnpadded(t);return i+s+o+e},decode(t,e){const{Err:n}=L.DER;let r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");const o=e[r++];const s=!!(o&128);let i=0;if(!s)i=o;else{const a=o&127;if(!a)throw new n("tlv.decode(long): indefinite length not supported");if(a>4)throw new n("tlv.decode(long): byte length is too big");const u=e.subarray(r,r+a);if(u.length!==a)throw new n("tlv.decode: length bytes not complete");if(u[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(const f of u)i=i<<8|f;r+=a;if(i<128)throw new n("tlv.decode(long): not minimal encoding")}const c=e.subarray(r,r+i);if(c.length!==i)throw new n("tlv.decode: wrong value length");return{v:c,l:e.subarray(r+i)}}},_int:{encode(t){const{Err:e}=L.DER;if(t<N)throw new e("integer: negative integers are not allowed");let n=k.numberToHexUnpadded(t);if(Number.parseInt(n[0],16)&8)n="00"+n;if(n.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return n},decode(t){const{Err:e}=L.DER;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return n(t)}},toSig(t){const{Err:e,_int:n,_tlv:r}=L.DER;const o=typeof t==="string"?d(t):t;k.abytes(o);const{v:s,l:i}=r.decode(48,o);if(i.length)throw new e("invalid signature: left bytes after parsing");const{v:c,l:a}=r.decode(2,s);const{v:u,l:f}=r.decode(2,a);if(f.length)throw new e("invalid signature: left bytes after parsing");return{r:n.decode(c),s:n.decode(u)}},hexFromSig(t){const{_tlv:e,_int:n}=L.DER;const r=e.encode(2,n.encode(t.r));const o=e.encode(2,n.encode(t.s));const s=r+o;return e.encode(48,s)}};const N=BigInt(0),H=BigInt(1),g=BigInt(2),v=BigInt(3),i=BigInt(4);function P(t){const b=h(t);const{Fp:m}=b;const n=(0,l.Field)(b.n,b.nBitLength);const e=b.toBytes||((t,e,n)=>{const r=e.toAffine();return k.concatBytes(Uint8Array.from([4]),m.toBytes(r.x),m.toBytes(r.y))});const r=b.fromBytes||(t=>{const e=t.subarray(1);const n=m.fromBytes(e.subarray(0,m.BYTES));const r=m.fromBytes(e.subarray(m.BYTES,2*m.BYTES));return{x:n,y:r}});function s(t){const{a:e,b:n}=b;const r=m.sqr(t);const o=m.mul(r,t);return m.add(m.add(o,m.mul(t,e)),n)}if(!m.eql(m.sqr(b.Gy),s(b.Gx)))throw new Error("bad generator point: equation left != right");function o(t){return k.inRange(t,H,b.n)}function i(e){const{allowedPrivateKeyLengths:t,nByteLength:n,wrapPrivateKey:r,n:o}=b;if(t&&typeof e!=="bigint"){if(k.isBytes(e))e=k.bytesToHex(e);if(typeof e!=="string"||!t.includes(e.length))throw new Error("invalid private key");e=e.padStart(n*2,"0")}let s;try{s=typeof e==="bigint"?e:k.bytesToNumberBE((0,U.ensureBytes)("private key",e,n))}catch(t){throw new Error("invalid private key, expected hex or "+n+" bytes, got "+typeof e)}if(r)s=(0,l.mod)(s,o);k.aInRange("private key",s,H,o);return s}function E(t){if(!(t instanceof B))throw new Error("ProjectivePoint expected")}const c=(0,U.memoized)((t,e)=>{const{px:n,py:r,pz:o}=t;if(m.eql(o,m.ONE))return{x:n,y:r};const s=t.is0();if(e==null)e=s?m.ONE:m.inv(o);const i=m.mul(n,e);const c=m.mul(r,e);const a=m.mul(o,e);if(s)return{x:m.ZERO,y:m.ZERO};if(!m.eql(a,m.ONE))throw new Error("invZ was invalid");return{x:i,y:c}});const a=(0,U.memoized)(t=>{if(t.is0()){if(b.allowInfinityPoint&&!m.is0(t.py))return;throw new Error("bad point: ZERO")}const{x:e,y:n}=t.toAffine();if(!m.isValid(e)||!m.isValid(n))throw new Error("bad point: x or y not FE");const r=m.sqr(n);const o=s(e);if(!m.eql(r,o))throw new Error("bad point: equation left != right");if(!t.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return true});class B{constructor(t,e,n){this.px=t;this.py=e;this.pz=n;if(t==null||!m.isValid(t))throw new Error("x required");if(e==null||!m.isValid(e))throw new Error("y required");if(n==null||!m.isValid(n))throw new Error("z required");Object.freeze(this)}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!m.isValid(e)||!m.isValid(n))throw new Error("invalid affine point");if(t instanceof B)throw new Error("projective point not allowed");const r=t=>m.eql(t,m.ZERO);if(r(e)&&r(n))return B.ZERO;return new B(e,n,m.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const n=m.invertBatch(t.map(t=>t.pz));return t.map((t,e)=>t.toAffine(n[e])).map(B.fromAffine)}static fromHex(t){const e=B.fromAffine(r((0,U.ensureBytes)("pointHex",t)));e.assertValidity();return e}static fromPrivateKey(t){return B.BASE.multiply(i(t))}static msm(t,e){return(0,f.pippenger)(B,n,t,e)}_setWindowSize(t){d.setWindowSize(this,t)}assertValidity(){a(this)}hasEvenY(){const{y:t}=this.toAffine();if(m.isOdd)return!m.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){E(t);const{px:e,py:n,pz:r}=this;const{px:o,py:s,pz:i}=t;const c=m.eql(m.mul(e,i),m.mul(o,r));const a=m.eql(m.mul(n,i),m.mul(s,r));return c&&a}negate(){return new B(this.px,m.neg(this.py),this.pz)}double(){const{a:t,b:e}=b;const n=m.mul(e,v);const{px:r,py:o,pz:s}=this;let i=m.ZERO,c=m.ZERO,a=m.ZERO;let u=m.mul(r,r);let f=m.mul(o,o);let l=m.mul(s,s);let d=m.mul(r,o);d=m.add(d,d);a=m.mul(r,s);a=m.add(a,a);i=m.mul(t,a);c=m.mul(n,l);c=m.add(i,c);i=m.sub(f,c);c=m.add(f,c);c=m.mul(i,c);i=m.mul(d,i);a=m.mul(n,a);l=m.mul(t,l);d=m.sub(u,l);d=m.mul(t,d);d=m.add(d,a);a=m.add(u,u);u=m.add(a,u);u=m.add(u,l);u=m.mul(u,d);c=m.add(c,u);l=m.mul(o,s);l=m.add(l,l);u=m.mul(l,d);i=m.sub(i,u);a=m.mul(l,f);a=m.add(a,a);a=m.add(a,a);return new B(i,c,a)}add(t){E(t);const{px:e,py:n,pz:r}=this;const{px:o,py:s,pz:i}=t;let c=m.ZERO,a=m.ZERO,u=m.ZERO;const f=b.a;const l=m.mul(b.b,v);let d=m.mul(e,o);let h=m.mul(n,s);let w=m.mul(r,i);let p=m.add(e,n);let y=m.add(o,s);p=m.mul(p,y);y=m.add(d,h);p=m.sub(p,y);y=m.add(e,r);let g=m.add(o,i);y=m.mul(y,g);g=m.add(d,w);y=m.sub(y,g);g=m.add(n,r);c=m.add(s,i);g=m.mul(g,c);c=m.add(h,w);g=m.sub(g,c);u=m.mul(f,y);c=m.mul(l,w);u=m.add(c,u);c=m.sub(h,u);u=m.add(h,u);a=m.mul(c,u);h=m.add(d,d);h=m.add(h,d);w=m.mul(f,w);y=m.mul(l,y);h=m.add(h,w);w=m.sub(d,w);w=m.mul(f,w);y=m.add(y,w);d=m.mul(h,y);a=m.add(a,d);d=m.mul(g,y);c=m.mul(p,c);c=m.sub(c,d);d=m.mul(p,h);u=m.mul(g,u);u=m.add(u,d);return new B(c,a,u)}subtract(t){return this.add(t.negate())}is0(){return this.equals(B.ZERO)}wNAF(t){return d.wNAFCached(this,t,B.normalizeZ)}multiplyUnsafe(t){const{endo:e,n}=b;k.aInRange("scalar",t,N,n);const r=B.ZERO;if(t===N)return r;if(this.is0()||t===H)return this;if(!e||d.hasPrecomputes(this))return d.wNAFCachedUnsafe(this,t,B.normalizeZ);let{k1neg:o,k1:s,k2neg:i,k2:c}=e.splitScalar(t);let a=r;let u=r;let f=this;while(s>N||c>N){if(s&H)a=a.add(f);if(c&H)u=u.add(f);f=f.double();s>>=H;c>>=H}if(o)a=a.negate();if(i)u=u.negate();u=new B(m.mul(u.px,e.beta),u.py,u.pz);return a.add(u)}multiply(o){const{endo:s,n:t}=b;k.aInRange("scalar",o,H,t);let i,c;if(s){const{k1neg:a,k1:u,k2neg:f,k2:l}=s.splitScalar(o);let{p:t,f:e}=this.wNAF(u);let{p:n,f:r}=this.wNAF(l);t=d.constTimeNegate(a,t);n=d.constTimeNegate(f,n);n=new B(m.mul(n.px,s.beta),n.py,n.pz);i=t.add(n);c=e.add(r)}else{const{p:e,f:n}=this.wNAF(o);i=e;c=n}return B.normalizeZ([i,c])[0]}multiplyAndAddUnsafe(t,e,n){const r=B.BASE;const o=(t,e)=>e===N||e===H||!t.equals(r)?t.multiplyUnsafe(e):t.multiply(e);const s=o(this,e).add(o(t,n));return s.is0()?undefined:s}toAffine(t){return c(this,t)}isTorsionFree(){const{h:t,isTorsionFree:e}=b;if(t===H)return true;if(e)return e(B,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:e}=b;if(t===H)return this;if(e)return e(B,this);return this.multiplyUnsafe(b.h)}toRawBytes(t=true){(0,U.abool)("isCompressed",t);this.assertValidity();return e(B,this,t)}toHex(t=true){(0,U.abool)("isCompressed",t);return k.bytesToHex(this.toRawBytes(t))}}B.BASE=new B(b.Gx,b.Gy,m.ONE);B.ZERO=new B(m.ZERO,m.ONE,m.ZERO);const u=b.nBitLength;const d=(0,f.wNAF)(B,b.endo?Math.ceil(u/2):u);return{CURVE:b,ProjectivePoint:B,normPrivateKeyToScalar:i,weierstrassEquation:s,isWithinCurveOrder:o}}function q(t){const e=(0,f.validateBasic)(t);k.validateObject(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"});return Object.freeze({lowS:true,...e})}function o(t){const E=q(t);const{Fp:p,n}=E;const d=p.BYTES+1;const h=2*p.BYTES+1;function B(t){return(0,l.mod)(t,n)}function v(t){return(0,l.invert)(t,n)}const{ProjectivePoint:x,normPrivateKeyToScalar:y,weierstrassEquation:w,isWithinCurveOrder:g}=P({...E,toBytes(t,e,n){const r=e.toAffine();const o=p.toBytes(r.x);const s=k.concatBytes;(0,U.abool)("isCompressed",n);if(n){return s(Uint8Array.from([e.hasEvenY()?2:3]),o)}else{return s(Uint8Array.from([4]),o,p.toBytes(r.y))}},fromBytes(t){const e=t.length;const n=t[0];const r=t.subarray(1);if(e===d&&(n===2||n===3)){const o=k.bytesToNumberBE(r);if(!k.inRange(o,H,p.ORDER))throw new Error("Point is not on curve");const s=w(o);let t;try{t=p.sqrt(s)}catch(t){const a=t instanceof Error?": "+t.message:"";throw new Error("Point is not on curve"+a)}const i=(t&H)===H;const c=(n&1)===1;if(c!==i)t=p.neg(t);return{x:o,y:t}}else if(e===h&&n===4){const o=p.fromBytes(r.subarray(0,p.BYTES));const u=p.fromBytes(r.subarray(p.BYTES,2*p.BYTES));return{x:o,y:u}}else{const f=d;const l=h;throw new Error("invalid Point, expected length of "+f+", or uncompressed "+l+", got "+e)}}});const b=t=>k.bytesToHex(k.numberToBytesBE(t,E.nByteLength));function m(t){const e=n>>H;return t>e}function A(t){return m(t)?B(-t):t}const r=(t,e,n)=>k.bytesToNumberBE(t.slice(e,n));class S{constructor(t,e,n){this.r=t;this.s=e;this.recovery=n;this.assertValidity()}static fromCompact(t){const e=E.nByteLength;t=(0,U.ensureBytes)("compactSignature",t,e*2);return new S(r(t,0,e),r(t,e,2*e))}static fromDER(t){const{r:e,s:n}=L.DER.toSig((0,U.ensureBytes)("DER",t));return new S(e,n)}assertValidity(){k.aInRange("r",this.r,H,n);k.aInRange("s",this.s,H,n)}addRecoveryBit(t){return new S(this.r,this.s,t)}recoverPublicKey(t){const{r:e,s:n,recovery:r}=this;const o=T((0,U.ensureBytes)("msgHash",t));if(r==null||![0,1,2,3].includes(r))throw new Error("recovery id invalid");const s=r===2||r===3?e+E.n:e;if(s>=p.ORDER)throw new Error("recovery id 2 or 3 invalid");const i=(r&1)===0?"02":"03";const c=x.fromHex(i+b(s));const a=v(s);const u=B(-o*a);const f=B(n*a);const l=x.BASE.multiplyAndAddUnsafe(c,u,f);if(!l)throw new Error("point at infinify");l.assertValidity();return l}hasHighS(){return m(this.s)}normalizeS(){return this.hasHighS()?new S(this.r,B(-this.s),this.recovery):this}toDERRawBytes(){return k.hexToBytes(this.toDERHex())}toDERHex(){return L.DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return k.hexToBytes(this.toCompactHex())}toCompactHex(){return b(this.r)+b(this.s)}}const e={isValidPrivateKey(t){try{y(t);return true}catch(t){return false}},normPrivateKeyToScalar:y,randomPrivateKey:()=>{const t=(0,l.getMinHashLength)(E.n);return(0,l.mapHashToField)(E.randomBytes(t),E.n)},precompute(t=8,e=x.BASE){e._setWindowSize(t);e.multiply(BigInt(3));return e}};function o(t,e=true){return x.fromPrivateKey(t).toRawBytes(e)}function s(t){const e=k.isBytes(t);const n=typeof t==="string";const r=(e||n)&&t.length;if(e)return r===d||r===h;if(n)return r===2*d||r===2*h;if(t instanceof x)return true;return false}function i(t,e,n=true){if(s(t))throw new Error("first arg must be private key");if(!s(e))throw new Error("second arg must be public key");const r=x.fromHex(e);return r.multiply(y(t)).toRawBytes(n)}const O=E.bits2int||function(t){if(t.length>8192)throw new Error("input is too large");const e=k.bytesToNumberBE(t);const n=t.length*8-E.nBitLength;return n>0?e>>BigInt(n):e};const T=E.bits2int_modN||function(t){return B(O(t))};const c=k.bitMask(E.nBitLength);function I(t){k.aInRange("num < 2^"+E.nBitLength,t,N,c);return k.numberToBytesBE(t,E.nByteLength)}function a(t,e,n=R){if(["recovered","canonical"].some(t=>t in n))throw new Error("sign() legacy options not supported");const{hash:r,randomBytes:o}=E;let{lowS:a,prehash:s,extraEntropy:i}=n;if(a==null)a=true;t=(0,U.ensureBytes)("msgHash",t);_(n);if(s)t=(0,U.ensureBytes)("prehashed msgHash",r(t));const c=T(t);const u=y(e);const f=[I(u),I(c)];if(i!=null&&i!==false){const w=i===true?o(p.BYTES):i;f.push((0,U.ensureBytes)("extraEntropy",w))}const l=k.concatBytes(...f);const d=c;function h(t){const e=O(t);if(!g(e))return;const n=v(e);const r=x.BASE.multiply(e).toAffine();const o=B(r.x);if(o===N)return;const s=B(n*B(d+o*u));if(s===N)return;let i=(r.x===o?0:2)|Number(r.y&H);let c=s;if(a&&m(s)){c=A(s);i^=1}return new S(o,c,i)}return{seed:l,k2sig:h}}const R={lowS:E.lowS,prehash:false};const j={lowS:E.lowS,prehash:false};function u(t,e,n=R){const{seed:r,k2sig:o}=a(t,e,n);const s=E;const i=k.createHmacDrbg(s.hash.outputLen,s.nByteLength,s.hmac);return i(r,o)}x.BASE._setWindowSize(8);function f(t,e,n,r=j){const o=t;e=(0,U.ensureBytes)("msgHash",e);n=(0,U.ensureBytes)("publicKey",n);const{lowS:s,prehash:i,format:c}=r;_(r);if("strict"in r)throw new Error("options.strict was renamed to lowS");if(c!==undefined&&c!=="compact"&&c!=="der")throw new Error("format must be compact or der");const a=typeof o==="string"||k.isBytes(o);const u=!a&&!c&&typeof o==="object"&&o!==null&&typeof o.r==="bigint"&&typeof o.s==="bigint";if(!a&&!u)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let f=undefined;let l;try{if(u)f=new S(o.r,o.s);if(a){try{if(c!=="compact")f=S.fromDER(o)}catch(t){if(!(t instanceof L.DER.Err))throw t}if(!f&&c!=="der")f=S.fromCompact(o)}l=x.fromHex(n)}catch(t){return false}if(!f)return false;if(s&&f.hasHighS())return false;if(i)e=E.hash(e);const{r:d,s:h}=f;const w=T(e);const p=v(h);const y=B(w*p);const g=B(d*p);const b=x.BASE.multiplyAndAddUnsafe(l,y,g)?.toAffine();if(!b)return false;const m=B(b.x);return m===d}return{CURVE:E,getPublicKey:o,getSharedSecret:i,sign:u,verify:f,ProjectivePoint:x,Signature:S,utils:e}}function s(u,t){const e=u.ORDER;let n=N;for(let t=e-H;t%g===N;t/=g)n+=H;const f=n;const r=g<<f-H-H;const o=r*g;const l=(e-H)/o;const d=(l-H)/g;const h=o-H;const w=r;const p=u.pow(t,l);const y=u.pow(t,(l+H)/g);let s=(t,e)=>{let r=p;let o=u.pow(e,h);let s=u.sqr(o);s=u.mul(s,e);let n=u.mul(t,s);n=u.pow(n,d);n=u.mul(n,o);o=u.mul(n,e);s=u.mul(n,t);let i=u.mul(s,o);n=u.pow(i,w);let c=u.eql(n,u.ONE);o=u.mul(s,y);n=u.mul(i,r);s=u.cmov(o,s,c);i=u.cmov(n,i,c);for(let n=f;n>H;n--){let t=n-g;t=g<<t-H;let e=u.pow(i,t);const a=u.eql(e,u.ONE);o=u.mul(s,r);r=u.mul(r,r);e=u.mul(i,r);s=u.cmov(o,s,a);i=u.cmov(e,i,a)}return{isValid:c,value:s}};if(u.ORDER%i===v){const f=(u.ORDER-v)/i;const l=u.sqrt(u.neg(t));s=(t,e)=>{let n=u.sqr(e);const r=u.mul(t,e);n=u.mul(n,r);let o=u.pow(n,f);o=u.mul(o,r);const s=u.mul(o,l);const i=u.mul(u.sqr(o),e);const c=u.eql(i,t);let a=u.cmov(s,o,c);return{isValid:c,value:a}}}return s}function c(d,h){(0,l.validateField)(d);if(!d.isValid(h.A)||!d.isValid(h.B)||!d.isValid(h.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const w=s(d,h.Z);if(!d.isOdd)throw new Error("Fp.isOdd is not implemented!");return t=>{let e,n,r,o,s,i,c,a;e=d.sqr(t);e=d.mul(e,h.Z);n=d.sqr(e);n=d.add(n,e);r=d.add(n,d.ONE);r=d.mul(r,h.B);o=d.cmov(h.Z,d.neg(n),!d.eql(n,d.ZERO));o=d.mul(o,h.A);n=d.sqr(r);i=d.sqr(o);s=d.mul(i,h.A);n=d.add(n,s);n=d.mul(n,r);i=d.mul(i,o);s=d.mul(i,h.B);n=d.add(n,s);c=d.mul(e,r);const{isValid:u,value:f}=w(n,i);a=d.mul(e,t);a=d.mul(a,f);c=d.cmov(c,r,u);a=d.cmov(a,f,u);const l=d.isOdd(t)===d.isOdd(a);a=d.cmov(d.neg(a),a,l);c=d.div(c,o);return{x:c,y:a}}}},{"./curve.js":2,"./modular.js":4,"./utils.js":5}],7:[function(t,N,o){"use strict";Object.defineProperty(o,"__esModule",{value:true});o.encodeToCurve=o.hashToCurve=o.schnorr=o.secp256k1=void 0;const s=t("@noble/hashes/sha256");const w=t("@noble/hashes/utils");const e=t("./_shortw_utils.js");const n=t("./abstract/hash-to-curve.js");const x=t("./abstract/modular.js");const p=t("./abstract/utils.js");const r=t("./abstract/weierstrass.js");const A=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");const h=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");const y=BigInt(1);const S=BigInt(2);const g=(t,e)=>(t+e/S)/e;function i(t){const e=A;const n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22);const i=BigInt(23),c=BigInt(44),a=BigInt(88);const u=t*t*t%e;const f=u*u*t%e;const l=(0,x.pow2)(f,n,e)*f%e;const d=(0,x.pow2)(l,n,e)*f%e;const h=(0,x.pow2)(d,S,e)*u%e;const w=(0,x.pow2)(h,o,e)*h%e;const p=(0,x.pow2)(w,s,e)*w%e;const y=(0,x.pow2)(p,c,e)*p%e;const g=(0,x.pow2)(y,a,e)*y%e;const b=(0,x.pow2)(g,c,e)*p%e;const m=(0,x.pow2)(b,n,e)*f%e;const E=(0,x.pow2)(m,i,e)*w%e;const B=(0,x.pow2)(E,r,e)*u%e;const v=(0,x.pow2)(B,S,e);if(!O.eql(O.sqr(v),t))throw new Error("Cannot find square root");return v}const O=(0,x.Field)(A,undefined,undefined,{sqrt:i});o.secp256k1=(0,e.createCurve)({a:BigInt(0),b:BigInt(7),Fp:O,n:h,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:true,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=h;const n=BigInt("0x3086d221a7d46bcde86c90e49284eb15");const r=-y*BigInt("0xe4437ed6010e88286f547fa90abfe4c3");const o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");const s=n;const i=BigInt("0x100000000000000000000000000000000");const c=g(s*t,e);const a=g(-r*t,e);let u=(0,x.mod)(t-c*n-a*o,e);let f=(0,x.mod)(-c*r-a*s,e);const l=u>i;const d=f>i;if(l)u=e-u;if(d)f=e-f;if(u>i||f>i){throw new Error("splitScalar: Endomorphism failed, k="+t)}return{k1neg:l,k1:u,k2neg:d,k2:f}}}},s.sha256);const b=BigInt(0);const c={};function m(t,...e){let n=c[t];if(n===undefined){const r=(0,s.sha256)(Uint8Array.from(t,t=>t.charCodeAt(0)));n=(0,p.concatBytes)(r,r);c[t]=n}return(0,s.sha256)((0,p.concatBytes)(n,...e))}const l=t=>t.toRawBytes(true).slice(1);const E=t=>(0,p.numberToBytesBE)(t,32);const a=t=>(0,x.mod)(t,A);const B=t=>(0,x.mod)(t,h);const u=o.secp256k1.ProjectivePoint;const d=(t,e,n)=>u.BASE.multiplyAndAddUnsafe(t,e,n);function v(t){let e=o.secp256k1.utils.normPrivateKeyToScalar(t);let n=u.fromPrivateKey(e);const r=n.hasEvenY()?e:B(-e);return{scalar:r,bytes:l(n)}}function T(t){(0,p.aInRange)("x",t,y,A);const e=a(t*t);const n=a(e*t+BigInt(7));let r=i(n);if(r%S!==b)r=a(-r);const o=new u(t,r,y);o.assertValidity();return o}const I=p.bytesToNumberBE;function R(...t){return B(I(m("BIP0340/challenge",...t)))}function f(t){return v(t).bytes}function j(t,e,n=(0,w.randomBytes)(32)){const r=(0,p.ensureBytes)("message",t);const{bytes:o,scalar:s}=v(e);const i=(0,p.ensureBytes)("auxRand",n,32);const c=E(s^I(m("BIP0340/aux",i)));const a=m("BIP0340/nonce",c,o,r);const u=B(I(a));if(u===b)throw new Error("sign failed: k is zero");const{bytes:f,scalar:l}=v(u);const d=R(f,o,r);const h=new Uint8Array(64);h.set(f,0);h.set(E(B(l+d*s)),32);if(!L(h,r,o))throw new Error("sign: Invalid signature produced");return h}function L(t,e,n){const r=(0,p.ensureBytes)("signature",t,64);const o=(0,p.ensureBytes)("message",e);const s=(0,p.ensureBytes)("publicKey",n,32);try{const i=T(I(s));const c=I(r.subarray(0,32));if(!(0,p.inRange)(c,y,A))return false;const a=I(r.subarray(32,64));if(!(0,p.inRange)(a,y,h))return false;const u=R(E(c),l(i),o);const f=d(i,a,B(-u));if(!f||!f.hasEvenY()||f.toAffine().x!==c)return false;return true}catch(t){return false}}o.schnorr=(()=>({getPublicKey:f,sign:j,verify:L,utils:{randomPrivateKey:o.secp256k1.utils.randomPrivateKey,lift_x:T,pointToBytes:l,numberToBytesBE:p.numberToBytesBE,bytesToNumberBE:p.bytesToNumberBE,taggedHash:m,mod:x.mod}}))();const k=(()=>(0,n.isogenyMap)(O,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(t=>BigInt(t)))))();const U=(()=>(0,r.mapToCurveSimpleSWU)(O,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:O.create(BigInt("-11"))}))();const _=(()=>(0,n.createHasher)(o.secp256k1.ProjectivePoint,t=>{const{x:e,y:n}=U(O.create(t[0]));return k(e,n)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:O.ORDER,m:1,k:128,expand:"xmd",hash:s.sha256}))();o.hashToCurve=(()=>_.hashToCurve)();o.encodeToCurve=(()=>_.encodeToCurve)()},{"./_shortw_utils.js":1,"./abstract/hash-to-curve.js":3,"./abstract/modular.js":4,"./abstract/utils.js":5,"./abstract/weierstrass.js":6,"@noble/hashes/sha256":12,"@noble/hashes/utils":13}],8:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:true});n.anumber=r;n.abytes=s;n.ahash=i;n.aexists=c;n.aoutput=a;function r(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function o(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function s(t,...e){if(!o(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function i(t){if(typeof t!=="function"||typeof t.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");r(t.outputLen);r(t.blockLen)}function c(t,e=true){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function a(t,e){s(t);const n=e.outputLen;if(t.length<n){throw new Error("digestInto() expects output buffer of length at least "+n)}}},{}],9:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:true});n.HashMD=void 0;n.setBigUint64=d;n.Chi=r;n.Maj=o;const f=t("./_assert.js");const l=t("./utils.js");function d(t,e,n,r){if(typeof t.setBigUint64==="function")return t.setBigUint64(e,n,r);const o=BigInt(32);const s=BigInt(4294967295);const i=Number(n>>o&s);const c=Number(n&s);const a=r?4:0;const u=r?0:4;t.setUint32(e+a,i,r);t.setUint32(e+u,c,r)}function r(t,e,n){return t&e^~t&n}function o(t,e,n){return t&e^t&n^e&n}class s extends l.Hash{constructor(t,e,n,r){super();this.blockLen=t;this.outputLen=e;this.padOffset=n;this.isLE=r;this.finished=false;this.length=0;this.pos=0;this.destroyed=false;this.buffer=new Uint8Array(t);this.view=(0,l.createView)(this.buffer)}update(e){(0,f.aexists)(this);const{view:n,buffer:r,blockLen:o}=this;e=(0,l.toBytes)(e);const s=e.length;for(let t=0;t<s;){const i=Math.min(o-this.pos,s-t);if(i===o){const c=(0,l.createView)(e);for(;o<=s-t;t+=o)this.process(c,t);continue}r.set(e.subarray(t,t+i),this.pos);this.pos+=i;t+=i;if(this.pos===o){this.process(n,0);this.pos=0}}this.length+=e.length;this.roundClean();return this}digestInto(t){(0,f.aexists)(this);(0,f.aoutput)(t,this);this.finished=true;const{buffer:e,view:n,blockLen:r,isLE:o}=this;let{pos:s}=this;e[s++]=128;this.buffer.subarray(s).fill(0);if(this.padOffset>r-s){this.process(n,0);s=0}for(let t=s;t<r;t++)e[t]=0;d(n,r-8,BigInt(this.length*8),o);this.process(n,0);const i=(0,l.createView)(t);const c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=c/4;const u=this.get();if(a>u.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<a;t++)i.setUint32(4*t,u[t],o)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);this.destroy();return n}_cloneInto(t){t||(t=new this.constructor);t.set(...this.get());const{blockLen:e,buffer:n,length:r,finished:o,destroyed:s,pos:i}=this;t.length=r;t.pos=i;t.finished=o;t.destroyed=s;if(r%e)t.buffer.set(n);return t}}n.HashMD=s},{"./_assert.js":8,"./utils.js":13}],10:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:true});n.crypto=void 0;n.crypto=typeof globalThis==="object"&&"crypto"in globalThis?globalThis.crypto:undefined},{}],11:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:true});n.hmac=n.HMAC=void 0;const s=t("./_assert.js");const i=t("./utils.js");class r extends i.Hash{constructor(t,e){super();this.finished=false;this.destroyed=false;(0,s.ahash)(t);const n=(0,i.toBytes)(e);this.iHash=t.create();if(typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen;this.outputLen=this.iHash.outputLen;const r=this.blockLen;const o=new Uint8Array(r);o.set(n.length>r?t.create().update(n).digest():n);for(let t=0;t<o.length;t++)o[t]^=54;this.iHash.update(o);this.oHash=t.create();for(let t=0;t<o.length;t++)o[t]^=54^92;this.oHash.update(o);o.fill(0)}update(t){(0,s.aexists)(this);this.iHash.update(t);return this}digestInto(t){(0,s.aexists)(this);(0,s.abytes)(t,this.outputLen);this.finished=true;this.iHash.digestInto(t);this.oHash.update(t);this.oHash.digestInto(t);this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);this.digestInto(t);return t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:o,blockLen:s,outputLen:i}=this;t=t;t.finished=r;t.destroyed=o;t.blockLen=s;t.outputLen=i;t.oHash=e._cloneInto(t.oHash);t.iHash=n._cloneInto(t.iHash);return t}destroy(){this.destroyed=true;this.oHash.destroy();this.iHash.destroy()}}n.HMAC=r;const o=(t,e,n)=>new r(t,e).update(n).digest();n.hmac=o;n.hmac.create=(t,e)=>new r(t,e)},{"./_assert.js":8,"./utils.js":13}],12:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:true});n.sha224=n.sha256=n.SHA256=void 0;const m=t("./_md.js");const E=t("./utils.js");const B=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]);const r=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);const v=new Uint32Array(64);class o extends m.HashMD{constructor(){super(64,32,8,false);this.A=r[0]|0;this.B=r[1]|0;this.C=r[2]|0;this.D=r[3]|0;this.E=r[4]|0;this.F=r[5]|0;this.G=r[6]|0;this.H=r[7]|0}get(){const{A:t,B:e,C:n,D:r,E:o,F:s,G:i,H:c}=this;return[t,e,n,r,o,s,i,c]}set(t,e,n,r,o,s,i,c){this.A=t|0;this.B=e|0;this.C=n|0;this.D=r|0;this.E=o|0;this.F=s|0;this.G=i|0;this.H=c|0}process(e,n){for(let t=0;t<16;t++,n+=4)v[t]=e.getUint32(n,false);for(let t=16;t<64;t++){const l=v[t-15];const d=v[t-2];const h=(0,E.rotr)(l,7)^(0,E.rotr)(l,18)^l>>>3;const w=(0,E.rotr)(d,17)^(0,E.rotr)(d,19)^d>>>10;v[t]=w+v[t-7]+h+v[t-16]|0}let{A:r,B:o,C:s,D:i,E:c,F:a,G:u,H:f}=this;for(let t=0;t<64;t++){const p=(0,E.rotr)(c,6)^(0,E.rotr)(c,11)^(0,E.rotr)(c,25);const y=f+p+(0,m.Chi)(c,a,u)+B[t]+v[t]|0;const g=(0,E.rotr)(r,2)^(0,E.rotr)(r,13)^(0,E.rotr)(r,22);const b=g+(0,m.Maj)(r,o,s)|0;f=u;u=a;a=c;c=i+y|0;i=s;s=o;o=r;r=y+b|0}r=r+this.A|0;o=o+this.B|0;s=s+this.C|0;i=i+this.D|0;c=c+this.E|0;a=a+this.F|0;u=u+this.G|0;f=f+this.H|0;this.set(r,o,s,i,c,a,u,f)}roundClean(){v.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0);this.buffer.fill(0)}}n.SHA256=o;class s extends o{constructor(){super();this.A=3238371032|0;this.B=914150663|0;this.C=812702999|0;this.D=4144912697|0;this.E=4290775857|0;this.F=1750603025|0;this.G=1694076839|0;this.H=3204075428|0;this.outputLen=28}}n.sha256=(0,E.wrapConstructor)(()=>new o);n.sha224=(0,E.wrapConstructor)(()=>new s)},{"./_md.js":9,"./utils.js":13}],13:[function(t,e,i){"use strict";Object.defineProperty(i,"__esModule",{value:true});i.Hash=i.nextTick=i.byteSwapIfBE=i.isLE=void 0;i.isBytes=r;i.u8=o;i.u32=c;i.createView=a;i.rotr=u;i.rotl=f;i.byteSwap=l;i.byteSwap32=d;i.bytesToHex=w;i.hexToBytes=g;i.asyncLoop=m;i.utf8ToBytes=E;i.toBytes=B;i.concatBytes=v;i.checkOpts=A;i.wrapConstructor=S;i.wrapConstructorWithOpts=O;i.wrapXOFConstructorWithOpts=T;i.randomBytes=I;const n=t("@noble/hashes/crypto");const s=t("./_assert.js");function r(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function o(t){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}function c(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))}function a(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function u(t,e){return t<<32-e|t>>>e}function f(t,e){return t<<e|t>>>32-e>>>0}i.isLE=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function l(t){return t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255}i.byteSwapIfBE=i.isLE?t=>t:t=>l(t);function d(e){for(let t=0;t<e.length;t++){e[t]=l(e[t])}}const h=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function w(e){(0,s.abytes)(e);let n="";for(let t=0;t<e.length;t++){n+=h[e[t]]}return n}const p={_0:48,_9:57,A:65,F:70,a:97,f:102};function y(t){if(t>=p._0&&t<=p._9)return t-p._0;if(t>=p.A&&t<=p.F)return t-(p.A-10);if(t>=p.a&&t<=p.f)return t-(p.a-10);return}function g(n){if(typeof n!=="string")throw new Error("hex string expected, got "+typeof n);const t=n.length;const r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const o=new Uint8Array(r);for(let t=0,e=0;t<r;t++,e+=2){const s=y(n.charCodeAt(e));const i=y(n.charCodeAt(e+1));if(s===undefined||i===undefined){const c=n[e]+n[e+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+e)}o[t]=s*16+i}return o}const b=async()=>{};i.nextTick=b;async function m(e,n,r){let o=Date.now();for(let t=0;t<e;t++){r(t);const s=Date.now()-o;if(s>=0&&s<n)continue;await(0,i.nextTick)();o+=s}}function E(t){if(typeof t!=="string")throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}function B(t){if(typeof t==="string")t=E(t);(0,s.abytes)(t);return t}function v(...n){let e=0;for(let t=0;t<n.length;t++){const o=n[t];(0,s.abytes)(o);e+=o.length}const r=new Uint8Array(e);for(let t=0,e=0;t<n.length;t++){const o=n[t];r.set(o,e);e+=o.length}return r}class x{clone(){return this._cloneInto()}}i.Hash=x;function A(t,e){if(e!==undefined&&{}.toString.call(e)!=="[object Object]")throw new Error("Options should be object or undefined");const n=Object.assign(t,e);return n}function S(e){const t=t=>e().update(B(t)).digest();const n=e();t.outputLen=n.outputLen;t.blockLen=n.blockLen;t.create=()=>e();return t}function O(n){const t=(t,e)=>n(e).update(B(t)).digest();const e=n({});t.outputLen=e.outputLen;t.blockLen=e.blockLen;t.create=t=>n(t);return t}function T(n){const t=(t,e)=>n(e).update(B(t)).digest();const e=n({});t.outputLen=e.outputLen;t.blockLen=e.blockLen;t.create=t=>n(t);return t}function I(t=32){if(n.crypto&&typeof n.crypto.getRandomValues==="function"){return n.crypto.getRandomValues(new Uint8Array(t))}if(n.crypto&&typeof n.crypto.randomBytes==="function"){return n.crypto.randomBytes(t)}throw new Error("crypto.getRandomValues must be defined")}},{"./_assert.js":8,"@noble/hashes/crypto":10}],"@bitcoinerlab/secp256k1":[function(t,H,e){"use strict";var i=t("@noble/curves/secp256k1");var n=t("@noble/curves/abstract/modular");var r=t("@noble/curves/abstract/utils");function o(n){var r=Object.create(null);if(n){Object.keys(n).forEach(function(t){if(t!=="default"){var e=Object.getOwnPropertyDescriptor(n,t);Object.defineProperty(r,t,e.get?e:{enumerable:true,get:function(){return n[t]}})}})}r.default=n;return Object.freeze(r)}var s=o(n);var c=o(r);const a=i.secp256k1.ProjectivePoint;const u="Expected Private";const f="Expected Point";const l="Expected Tweak";const P="Expected Hash";const d="Expected Signature";const h="Expected Extra Data (32 bytes)";const w="Expected Scalar";const q="Bad Recovery Id";const C=32;const F=32;const p=new Uint8Array([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,186,174,220,230,175,72,160,59,191,210,94,140,208,54,65,65]);const D=32;const M=new Uint8Array(32);const V=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,69,81,35,25,80,183,95,196,64,45,161,114,47,201,186,238]);const z=BigInt(1);function Z(t){return t instanceof Uint8Array}function y(e,n){for(let t=0;t<32;++t){if(e[t]!==n[t]){return e[t]<n[t]?-1:1}}return 0}function g(t){return y(t,M)===0}function b(t){if(!(t instanceof Uint8Array)||t.length!==F||y(t,p)>=0){return false}return true}function m(t){return t instanceof Uint8Array&&t.length===64&&y(t.subarray(0,32),p)<0&&y(t.subarray(32,64),p)<0}function K(t){return Z(t)&&t.length===64&&y(t.subarray(0,32),V)<0}function W(t){return!(g(t.subarray(0,32))||g(t.subarray(32,64)))}function E(t){return t instanceof Uint8Array&&t.length===C}function B(t){return t===undefined||t instanceof Uint8Array&&t.length===D}function v(t){let e;if(typeof t==="bigint"){e=t}else if(typeof t==="number"&&Number.isSafeInteger(t)&&t>=0){e=BigInt(t)}else if(typeof t==="string"){if(t.length!==64)throw new Error("Expected 32 bytes of private scalar");e=c.hexToNumber(t)}else if(t instanceof Uint8Array){if(t.length!==32)throw new Error("Expected 32 bytes of private scalar");e=c.bytesToNumberBE(t)}else{throw new TypeError("Expected valid private scalar")}if(e<0)throw new Error("Expected private scalar >= 0");return e}function x(t){return i.secp256k1.utils.normPrivateKeyToScalar(t)}function G(t,e){const n=x(t);const r=v(e);const o=c.numberToBytesBE(s.mod(n+r,i.secp256k1.CURVE.n),32);return i.secp256k1.utils.isValidPrivateKey(o)?o:null}function Y(t,e){const n=x(t);const r=v(e);const o=c.numberToBytesBE(s.mod(n-r,i.secp256k1.CURVE.n),32);return i.secp256k1.utils.isValidPrivateKey(o)?o:null}function X(t){const e=x(t);const n=c.numberToBytesBE(i.secp256k1.CURVE.n-e,32);return i.secp256k1.utils.isValidPrivateKey(n)?n:null}function A(t,e,n){const r=I(t);const o=v(e);const s=a.BASE.multiplyAndAddUnsafe(r,o,z);if(!s)throw new Error("Tweaked point at infinity");return s.toRawBytes(n)}function J(t,e,n){const r=I(t);const o=typeof e==="string"?e:c.bytesToHex(e);const s=c.hexToNumber(o);return r.multiply(s).toRawBytes(n)}function S(t,e){if(t===undefined){return e!==undefined?L(e):true}return!!t}function O(t){try{return t()}catch(t){return null}}function T(t){return i.schnorr.utils.lift_x(c.bytesToNumberBE(t))}function I(t){return t.length===32?T(t):a.fromHex(t)}function R(t,e){if(t.length===32!==e)return false;try{if(e)return!!T(t);else return!!a.fromHex(t)}catch(t){return false}}function j(t){return R(t,false)}function L(t){const e=33;return R(t,false)&&t.length===e}function k(t){return i.secp256k1.utils.isValidPrivateKey(t)}function U(t){return R(t,true)}function Q(n,r){if(!U(n)){throw new Error(f)}if(!b(r)){throw new Error(l)}return O(()=>{const t=A(n,r,true);const e=t[0]%2===1?1:0;return{parity:e,xOnlyPubkey:t.slice(1)}})}function _(t){if(!j(t)){throw new Error(f)}return t.slice(1,33)}function N(t,e){if(!k(t)){throw new Error(u)}return O(()=>i.secp256k1.getPublicKey(t,S(e)))}function $(t){if(!k(t)){throw new Error(u)}return _(N(t))}function tt(t,e){if(!j(t)){throw new Error(f)}return I(t).toRawBytes(S(e,t))}function et(t,e,n){if(!j(t)){throw new Error(f)}if(!b(e)){throw new Error(l)}return O(()=>J(t,e,S(n,t)))}function nt(n,r,o){if(!j(n)||!j(r)){throw new Error(f)}return O(()=>{const t=I(n);const e=I(r);if(t.equals(e.negate())){return null}else{return t.add(e).toRawBytes(S(o,n))}})}function rt(t,e,n){if(!j(t)){throw new Error(f)}if(!b(e)){throw new Error(l)}return O(()=>A(t,e,S(n,t)))}function ot(t,e){if(!k(t)){throw new Error(u)}if(!b(e)){throw new Error(l)}return O(()=>G(t,e))}function st(t,e){if(!k(t)){throw new Error(u)}if(!b(e)){throw new Error(l)}return O(()=>Y(t,e))}function it(t){if(!k(t)){throw new Error(u)}return X(t)}function ct(t,e,n){if(!k(e)){throw new Error(u)}if(!E(t)){throw new Error(w)}if(!B(n)){throw new Error(h)}return i.secp256k1.sign(t,e,{extraEntropy:n}).toCompactRawBytes()}function at(t,e,n){if(!k(e)){throw new Error(u)}if(!E(t)){throw new Error(w)}if(!B(n)){throw new Error(h)}const r=i.secp256k1.sign(t,e,{extraEntropy:n});return{signature:r.toCompactRawBytes(),recoveryId:r.recovery}}function ut(t,e,n){if(!k(e)){throw new Error(u)}if(!E(t)){throw new Error(w)}if(!B(n)){throw new Error(h)}return i.schnorr.sign(t,e,n)}function ft(t,e,n,r){if(!E(t)){throw new Error(P)}if(!m(e)||!W(e)){throw new Error(d)}if(n&2){if(!K(e))throw new Error(q)}if(!U(e.subarray(0,32))){throw new Error(d)}const o=i.secp256k1.Signature.fromCompact(e).addRecoveryBit(n);const s=o.recoverPublicKey(t);if(!s)throw new Error(d);return s.toRawBytes(S(r))}function lt(t,e,n,r){if(!j(e)){throw new Error(f)}if(!m(n)){throw new Error(d)}if(!E(t)){throw new Error(w)}return i.secp256k1.verify(n,t,e,{lowS:r})}function dt(t,e,n){if(!U(e)){throw new Error(f)}if(!m(n)){throw new Error(d)}if(!E(t)){throw new Error(w)}return i.schnorr.verify(n,t,e)}e.isPoint=j;e.isPointCompressed=L;e.isPrivate=k;e.isXOnlyPoint=U;e.pointAdd=nt;e.pointAddScalar=rt;e.pointCompress=tt;e.pointFromScalar=N;e.pointMultiply=et;e.privateAdd=ot;e.privateNegate=it;e.privateSub=st;e.recover=ft;e.sign=ct;e.signRecoverable=at;e.signSchnorr=ut;e.verify=lt;e.verifySchnorr=dt;e.xOnlyPointAddTweak=Q;e.xOnlyPointFromPoint=_;e.xOnlyPointFromScalar=$},{"@noble/curves/abstract/modular":4,"@noble/curves/abstract/utils":5,"@noble/curves/secp256k1":7}]},{},[])("@bitcoinerlab/secp256k1")});